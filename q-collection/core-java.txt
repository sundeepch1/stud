1. StringBuffer vs StringBuilder
StringBuffer is synchronized i.e. thread safe. It means two threads can't call the methods of StringBuffer simultaneously.
StringBuffer is less efficient than StringBuilder.
vs
StringBuilder is non-synchronized i.e. not thread safe. It means two threads can call the methods of StringBuilder simultaneously.
StringBuilder is more efficient than StringBuffer.

2. Comparable vs Comparator:-
1. Comparable interface can be used to provide single way of sorting whereas Comparator interface is used to provide different ways of sorting.
2. For using Comparable, Class needs to implement it whereas for using Comparator we don’t need to make any change in the class.
3. Comparable interface is in java.lang package whereas Comparator interface is present in java.util package.
4. We don’t need to make any code changes at client side for using Comparable, Arrays.sort() or Collection.sort() methods automatically uses the compareTo() method of the class. For Comparator, client needs to provide the Comparator class to use in compare() method.

3. Object Class method
protected Object clone() throws CloneNotSupportedException
      Creates and returns a copy of this object.
public boolean equals(Object obj)
      Indicates whether some other object is "equal to" this one.
protected void finalize() throws Throwable
      Called by the garbage collector on an object when garbage
      collection determines that there are no more references to the object
public final Class getClass()
      Returns the runtime class of an object.
public int hashCode()
      Returns a hash code value for the object.
public String toString()

4) How to call parent class method with child object.
We can call parent class method with child object by super keyword or by reflection package.
import java.lang.reflect.*;
class A {
    public void method() {
        System.out.println("In a");
    }
}
class B extends A {
    @Override
    public void method() {
        System.out.println("In b");
    }
}
public class Main
{
	public static void main(String[] args) {
		A b = new B();
        b.method();
        try {
			b.getClass()
    .getSuperclass()
    .getMethod("method", new Class[]{} )
    .invoke(b.getClass().getSuperclass().newInstance() ,new Object[]{});
		} catch (IllegalAccessException | IllegalArgumentException | InvocationTargetException | NoSuchMethodException
				| SecurityException | InstantiationException e) {
			// TODO Auto-generated catch block
			e.printStackTrace();
		}
	}
}

5.Lambda Expression in java.
It is short hand syntax, which is first step in functional programming. A Java lambda expression is thus a function which can be created without belonging to any class. A Java lambda expression can be passed around as if it was an object and executed on demand. Java lambda expressions are commonly used to implement simple event listeners / callbacks, or in functional programming with the Java Streams API. In other words, an interface is still a functional interface even if it contains default and static methods, as long as the interface only contains a single. Lambda Expressions vs. Anonymous Interface Implementations.

6. What is difference between Heap and Stack Memory in Java JVM
1) 4) Visibility: One more difference between heap and stack memory comes from visibility and sharing perspective. Heap memory is shared by all threads hence it is also known as the main memory but stack memory is local to threads and local variable created there was not visible to others.
2) Size: One of the significant differences between Stack and heap comes from their size. Heap space in Java is much bigger than the Stack memory. This is partly due to the fact that whenever a new thread is created in JVM, separate stack memory is allocated to them.
3) Resizing: JVM allows you to resize both heap and stack in Java, though you need to use different JVM flags for that. You can use -Xms and -Xmx to specify the starting and maximum heap memory in Java. Similarly, you can use the -Xss to specify the stack size of individual threads in JVM.
4) Usage: Another significant difference between heap and stack memory comes from their usage perspective. Heap memory is used to store objects in Java. No matter where you create object e.g. inside a method, a class, or a code block, they are always created in heap space and memory is allocated from the heap.One little exception of that is String literals which live in String pool, which was not part of the heap until Java 7. Earlier String pool was created on metaspace, which was separate memory are in JVM used to store class metadata, but from JDK 7 onwards String pool is merged into heap space.On the other hand, Stack memory is used to store local variables e.g. primitive int and boolean variables, method frames, and call stack.
5) Order: Heap is a large memory area where objects can be created and stored in any order but Stack memory is structured as Stack data structure i.e. LIFO where method calls are stored as last in first out order. This is why you can use recursion in Java.
6) Heap and Stack Memory Errors: You get different errors when heap or stack memory gets filled. For example, a faulty recursive algorithm can quickly make Stack memory filled up with recursive method calls in that case you will see java.lang.StackOverFlowError. But, when there is no more space left in heap to allocate a new object than you will see the OutOfMemoryError in java e.g. java.lang.OutOfMemoryError: Java Heap Space.

7. Advantages of wrapper class
1)Collections in the first place, for example,List<Integer>, you cannot use primitive int here. 
2)Actually any generic class / interface that can work with different object types


















